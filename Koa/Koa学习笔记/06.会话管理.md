# 会话管理

一般只要涉及到用户系统，就会涉及到会话管理。常见的会话保持有：`cookie + session` 和 `token` 两种方式。

## cookie

> koa2 中操作 cookie 使用的是 [cookies](https://github.com/pillarjs/cookies) 模块

Koa2 自带 cookie 处理方法，不需要中间件支持。

读写 cookie 的方法：

+ `ctx.cookies.get(name, [options])` 读取上下文请求中的中的 cookie 。
+ `ctx.cookies.set(name, value, [options])` 在上下文中写入 cookie 。

  `options`：

  + `maxAge`: 最大有效时长（毫秒数）。
  + `expires`：失效时间（Date 对象），默认回话结束时失效。
  + `path`: cookie 所在的路径，默认为 `'/'`。
  + `domain`: cookie 所在的域名。
  + `httpOnly`: 是否仅通过 HTTP(S) 发送，客户端 JavaScript 不可用，默认为 `true`。
  + `overwirte`: 是否允许被重写，默认为 `false`。
  + `secure`: 是否仅通过 HTTPS 发送 cookie，对于 HTTP 默认为 `false`，对于 HTTPS 默认为 `true`。
  + `signed`: 是否要对 cookie 进行签名，默认为 `false`。
  + `sameSite`: 设置 cookie 是否为相同站点，默认为 `false`，可以将其设置为 `'strict'`，`'lax'` 或 `true`。

```js
const Koa = require('koa')
const app = new Koa()

app.use(async (ctx) => {
  if(ctx.url === '/user') {
    // 读取 cookie
    const usercookie = ctx.cookies.get('user')
    if (usercookie === undefined) {
      // 写入 cookie
      ctx.cookies.set('user', JSON.stringify({
        id: 1,
        name: 'leo'
      }), {
        demain: 'localhost',             // 写 cookie 所在的域名
        path: '/',                       // 写 cookie 所在的路径
        maxAge: 1000*60*60*24,           // cookie 有效时长（24小时）
        httpOnly: false,                 // 是否仅通过 HTTP(S) 发送
        overwrite: false                 // 是否允许重写
      })
    }
    ctx.body = 'cookie is ok'
  } else {
    if (ctx.cookies.get('user')) {
      // 读取 cookie
      ctx.body = ctx.cookies.get('user')
    } else {
      ctx.body = 'cookie is none'
    }
  }
})
```

## session

session 需要自己实现或通过第三方中间件实现。

session 操作一般有一下方案：

+ 如果 session 数据量很小，可以直接在内存中。
+ 如果 session 数据量很大，则需要存储介质存放 session 数据。

基于 session 和 cookie 的后端用户认证方法：

+ 服务器端维护一个 `store`，用来存储（数据库存储、内存缓存） `session` 的数据。
+ 第一次登录时创建一个新的 `session`，并产生一个 `sid`，这个 `sid` 通过请求响应存储在浏览器 `cookie` 里。
+ 下一次客户端发出 HTTP 请求时携带 `cookie` 数据，服务器通过 cookie 携带的 sid 找到存储的 session 数据。
+ 登录后，会维持一个会话状态（一般是30分钟），用来判断是否已经登录。如果过期，就清空 `session` 数据，返回重新登录页面。
+ 注销时，也是通过 `sid` 来查找 `session` 数据，然后把 `session` 清空。

### 自定义 session 中间件

自定义一个简单的 session 中间件。

### 数据库存储方案

将 session 存放在 MySQL 数据库中需要用到中间件：

+ `koa-session-minimal` 适用于 koa2 的 session 中间件，提供存储介质的读写接口。

+ `koa-mysql-session` 为 `koa-session-minimal` 提供 MySQL 数据库的 session 数据读写操作。

将 sessionId 和对应的数据存到数据库，将数据库存储的 sessionId 存到页面的 cookie 中。

根据 cookie 中的 sessionId 获取对应的 session 信息。

```js
const Koa = require('koa')
const session = require('koa-session-minimal')
const MysqlSession = require('koa-mysql-session')

const app = new Koa()

// 配置存储 session 信息的 MySQL
let store = new MysqlSession({
  user: 'root',
  password: '123456',
  database: 'koa_demo',
  host: '127.0.0.1',
  port: 3306
})

// 存放sessionId的cookie配置
let cookie = {
  demain: 'localhost',             // 写 cookie 所在的域名
  path: '/',                       // 写 cookie 所在的路径
  maxAge: 1000*60*60*24,           // cookie 有效时长（24小时）
  expires: new Date('2019-10-20'), // cookie 失效日期
  httpOnly: false,                 // 是否仅通过 HTTP(S) 发送
  overwrite: false                 // 是否允许重写
}

app.use(session({
  key: 'SEESION_ID',
  store: store,
  cookie: cookie
}))

// 使用 session 中间件
app.use(async (ctx) => {
  // 设置 session
  if (ctx.url === '/set') {
    ctx.session = {
      user_id: Math.random().toString(36).substr(2),
      count: 0
    }
    ctx.body = ctx.session
  } else if(ctx.url === '/') {
    // 读取 session 信息
    ctx.session.count  = ctx.session.count + 1
    ctx.body = ctx.session
  }
})

app.listen(3000, () => console.log('http server is runing at port 3000'))
```
